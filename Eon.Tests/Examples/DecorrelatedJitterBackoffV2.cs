namespace Eon.Tests.Examples;

#region Example1

/// <summary>
/// Example <see cref="Schedule"/> with implementation copied from
/// https://github.com/App-vNext/Polly/blob/main/src/Polly.Core/Retry/RetryHelper.cs#L86C29-L86C56
/// </summary>
public sealed record DecorrelatedJitterBackoffV2(Duration BaseDelay, Func<double> Randomizer)
    : Schedule
{
    // A factor used within the formula to help smooth the first calculated delay.
    const double PFactor = 4.0;

    // A factor used to scale the median values of the retry times generated by
    // the formula to be _near_ whole seconds, to aid Polly user comprehension.
    // This factor allows the median values to fall approximately at 1, 2, 4 etc
    // seconds, instead of 1.4, 2.8, 5.6, 11.2.
    const double RpScalingFactor = 1 / 1.4d;

    const double ExponentialFactor = 2.0;

    public override int? Count => null;
    public override bool CanCount => false;

    public override IEnumerator<Duration> GetEnumerator()
    {
        double prev = 0;
        for (int attempt = 0; ; attempt++)
        {
            // Upper-bound to prevent overflow beyond TimeSpan.MaxValue.
            double maxTimeSpanDouble = (double)TimeSpan.MaxValue.Ticks - 1000;

            long targetTicksFirstDelay = ((TimeSpan)BaseDelay).Ticks;

            double t = attempt + Randomizer();
            double next = Math.Pow(ExponentialFactor, t) * Math.Tanh(Math.Sqrt(PFactor * t));

            double formulaIntrinsicValue = next - prev;
            prev = next;

            yield return TimeSpan.FromTicks(
                (long)
                    Math.Min(
                        formulaIntrinsicValue * RpScalingFactor * targetTicksFirstDelay,
                        maxTimeSpanDouble
                    )
            );
        }
    }
}

public static class DecorrelatedJitterBackoffV2Tests
{
    [Fact]
    public static void Case1()
    {
        Random seededRandom = new Random(123456);
        Schedule schedule = new DecorrelatedJitterBackoffV2(
            TimeSpan.FromSeconds(1),
            () => seededRandom.NextDouble()
        ).Take(10);
        schedule
            .Select(x => x.ToString())
            .Should()
            .ContainInConsecutiveOrder(
                "Duration(00:00:00.6650427)",
                "Duration(00:00:00.8275104)",
                "Duration(00:00:01.4038789)",
                "Duration(00:00:04.4717195)",
                "Duration(00:00:12.9353367)",
                "Duration(00:00:11.7150076)",
                "Duration(00:00:20.2590917)",
                "Duration(00:01:07.6758225)",
                "Duration(00:02:27.1149322)",
                "Duration(00:06:13.7526914)"
            );
    }
}

#endregion
